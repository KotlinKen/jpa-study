4장 엔티티 매핑
jpa를 사용하는데 가장 중요한 것은 엔티티와 테이블을 매핑하는 것이다
매핑할때는 어노테이션을 숙지하고 사용해야한다
jpa는 다양한 어노테이션을 지원하는데 크기 4가지로 분류 할 수 있다.

1. 객체와 테이블 매핑 : @Entity, @Table
2. 기본 키 매핑 : @id
3. 필드와 컬럼 매필 : @Coulmn
4. 연관관계 매핑 : @ManyToOne, @JoinColumn

*참고 매핑 정보는 XML이나 어노테이션 중에 선택해서 기술하면 됨
  책에는 어노테이션을 사용함 각각 장단점이 있지만 어노테이션을 사용하는 쪽이 좀더 쉽고 직관적이다
궁금하신 사람은 아래 링크를 한번 읽어봐도 좋을 것 같다
https://drsggg.tistory.com/394


4.1 @Entity
jpa를 사용하해서 테이블과 매핑할 클래스는 @Entity 어노테이션을 필수로 붙여야함

속성 name : jpa에서 사용할 엔티티를 이름을 지정 보통 기본값이 클래스이름을 사용
만약 다른 패키지에 이름이 같은 엔티티 존재시 출동하지 않도록 해야함
설정하지 않으면 클래스 이름을 그대로 사용함

적용시 주의사항
1.기본 생성자는 필수
2.final클래스 , enum,interface,inner 클래스는 사용 불가
3.저장할 필드에 final 을 사용하면 안됨


4.2 Table
엔티티와 매핑할 테이블을 지정함 생략이 매핑한 엔티티 이름을 테이블 이름으로 사용함

속성
1.name   매핑할 테이블 이름 
2.catalog catalog 기능이 있는 데이터베이스에서 catalog를 매핑한다
3.schema sechma 기능이 있는 데이터베이스에서 schema를 매핑한다

4.4 데이터베이스 스키마 자동 생성
jpa는 데이터베이스 스키마를 자동으로 생성하는 기능을 지원한다. (flyway 랑 비슷한 개념 인듯?)
jpa는 매핑 정보와 데이터베이스 방언을 사용해서 데이터베이스 스키마를 생성함

persistence.xml 에 다음 속성 추가
<property name="hibernate.hbm2ddl.auto" value="create"/>

자동 생성되는 DDL 은 지정한 데이터베이스 방언에 따라 달라진다
만약 오라클이였다면 VACHAR - > VARCHAR2 , INTERGER - > NUMBER로 타입이 생성됨

참고
스키마 자동 생성을 사용시 개발자가 직접 테이블을 생성하는 수고를 덜 수 있지만 자동생성이 만든 DDL 운영 환경에서 사용할 만큼 완벽하지 않음.
매핑을 어떻게 해야 할지만 참고

4.5 DDL 생성기능
조건 회원 이름은 필수로 입력해야하고 , 10자를 초과하면 안된다는 제약조건이 추가될시

AS_IS
  @Column(name = "NAME")
    private String username;

TO_BE
  @Column(name = "NAME" , nullable = false, length = 10)
    private String username;

@Column의 속성 length , nullable 을 포함에서 이런 기능들은 단지 DDL 자동 생성할 때만 사용되고 JPA실행 로직에는 영향을 주지 않음

4.6 기본키 맵핑

데이터터베이스 기본키를 맵핑 하는 방법은 2가지
1. 직접 할당 : 기본 키 생성을 데이터베이스에 위임한다. 
2. 자동 생성 : 대리키 사용방속
   -IDENTITY : 기본 키 생성을 데이터베이스에 위임한다
   -SEQUENCE : 데이터베이스 시퀀스를 사용해서 기본 키를 할당한다.
   -TABLE : 키 생성 테이블을 사용한다.

자동생성이 전략이 다양한 이유는 지원하는 방식이 다르기 때문이다.
ORACLE - 시퀀스를 제공
MYSQL - AUTO_INCREMENT 기능 제공
TABLE 전략은 키 생성용 테이블을 하나 만들어두고 시퀀스처럼 사용하는 방법임
이 전략은 테이블을 활용하므로 모든 데이터베이스에서 사용할 수 있음

기본 키를 직접 할당하려면 @Id 만 사용하면 되고 , 자동생성 전략을 사용하려면 @Id에 @GenerateValue를 추가하면 된다


IDENTITY 전략
기본 키 생성을 데이터베이스에 위임하는 전략 주로 MYSQL,POSTGRESQL 등에서 사용한다


POSTGRESQL 
create table board (
ID  SERIAL PRIMARY KEY,
DATA VARCHAR(255)
);

SELECT * FROM BOARD

INSERT INTO BOARD(DATA) VALUES('A')

#참고
IDENTITY 전략은 데이터를 데이터베이스에 INSERT 한 우에 기본 키 값을 조회할 수 있다
따라서 엔티티에 식별자 값을 할당하려면 JPA는 추가로 데이터베이스를 조회해야한다 

4.6.3 SEQUENCE 전략
데이터베이스 시퀀스는 유일한 값을 순서대로 생성하는 특별한 데이터베이스 오브젝트다
시퀀스 전략은 이 시퀀스를 사용해서 기본 키를 생성한다.
시퀀스를 지원하는 오라클,포스트그레 H2등 사용할 수 있다


CREATE TABLE BOARD2 (
	ID BIGINT NOT NULL PRIMARY KEY,
	DATA VARCHAR(255)
)

CREATE SEQUENCE BOARD_SEQ START WITH 1 INCREMENT BY 1

시퀀스 사용 코드는 IDENTITY 전략과 같지만 내부 동작 방식은 다르다
 시퀀스 전략은 em.persist()를 호출할때 먼저 데이터베이스 시퀀스를 사용해서 식별자랄 조회한다. 그리고 조회한 식별자를 엔티티데 할당한 후에 컨텍스트에 저장한다.
이후 트랜잭션 커밋해서 플러시가 일어난다




4.6.6 기본 키 매핑 정리
1.직접 할당 : em.persist()를 호출하기 전에 애플리케이션에서 직접 식별자 값을 할당해야 한다.만약 식별자 값이 없으면 예외가 발생한다

2:시퀀스 : 데이터베이스 시퀀스에서 식별자 값을 획득한 후 영속성 컨텍스트에 저장한다

3:테이블 데이터베이스 시퀀스 생성용 테이블에서 식별자 값을 획득한 후 영속성 컨텍스트에 저장한다

4: 아이덴티티 : 데이터베이스에 엔티티를 저장해서 식별자 값을 획득한 후 영속성 컨텍스트에 저장한다

참고
권장하는 식별자 선택 전략
데이터베이스 기본 키는 다음 3가지 조건을 모두 만족해야 한다
1. null값은 허용하지 않는다
2. 유일해야 한다.
3. 변해선 안 된다.

테이블의 기본 키를 선택하는 전략은 크게 2가지가 있다
2. 자연키
- 비즈니스에 의미가 있는 키
 ex(주민등록번호 , 이메일 , 전화번호)
대리 키 (surrogate key)
-비즈니스와 관련 없는 임의로 만들어진 키 , 대체 키로도 불린다
 








